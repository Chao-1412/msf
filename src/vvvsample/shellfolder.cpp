//
// (C) Copyright by Victor Derks
//
// See README.TXT for the details of the software licence.
//
#include "stdafx.h"

#include "shellfolderclsid.h"
#include "shellfolderviewcb.h"
#include "shellfolderdataobject.h"
#include "enumidlist.h"
#include "vvvitem.h"
#include "vvvfile.h"
#include "vvvpropertysheet.h"
#include "resource.h"

using std::wstring;
using std::make_unique;

// Defines for the item context menu.
const UINT ID_DFM_CMD_OPEN = 0;

class __declspec(novtable) ShellFolder :
    public ATL::CComObjectRootEx<ATL::CComSingleThreadModel>,
    public ATL::CComCoClass<ShellFolder, &__uuidof(ShellFolder)>,
    public MSF::ShellFolderImpl<ShellFolder, VVVItem>,
    public MSF::IBrowserFrameOptionsImpl,
    public MSF::IItemNameLimitsImpl<ShellFolder, VVVItem>
{
public:
    BEGIN_COM_MAP(ShellFolder)
        COM_INTERFACE_ENTRY2(IPersist, IPersistFolder2)
        COM_INTERFACE_ENTRY(IPersistFolder)
        COM_INTERFACE_ENTRY(IPersistFolder2)
        COM_INTERFACE_ENTRY(IPersistFolder3)
        COM_INTERFACE_ENTRY(IPersistIDList)
        COM_INTERFACE_ENTRY(IShellFolder)  // included in this sample for backwards (win9x) compatibility.
        COM_INTERFACE_ENTRY(IShellFolder2)
        COM_INTERFACE_ENTRY(IShellDetails) // included in this sample for backwards (win9x) compatibility.
        COM_INTERFACE_ENTRY(IBrowserFrameOptions)
        COM_INTERFACE_ENTRY(IShellIcon)
        COM_INTERFACE_ENTRY(IItemNameLimits)
        COM_INTERFACE_ENTRY(IDropTarget)   // enable drag and drop support.
        COM_INTERFACE_ENTRY(IObjectWithFolderEnumMode) // used by Windows 7 and up
        COM_INTERFACE_ENTRY(IExplorerPaneVisibility) // used by Windows Vista and up.
    END_COM_MAP()

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    static HRESULT WINAPI UpdateRegistry(BOOL bRegister) noexcept
    {
        return ShellFolderImpl<ShellFolder, VVVItem>::UpdateRegistry(
            bRegister, IDR_SHELLFOLDER,
            L"VVV Sample ShellFolder ShellExtension ", wszVVVFileRootExt, IDS_SHELLFOLDER_TYPE);
    }

    // Purpose: called by MSF when the shell folder needs to show a sub folder.
    void InitializeSubFolder(const CVVVItemList& items)
    {
        m_strSubFolder.clear();

        for (auto item : items)
        {
            if (!m_strSubFolder.empty())
            {
                m_strSubFolder += L"\\";
            }

            m_strSubFolder += MSF::ToString(item.GetID());
        }
    }

    // Purpose: Create the shellfolderviewcb that will be used to catch callback events
    //          generated by the system folder view.
    ATL::CComPtr<IShellFolderViewCB> CreateShellFolderViewCB()
    {
        return ShellFolderViewCB::CreateInstance(GetRootFolder());
    }

    // Purpose: called by MSF/shell when a number of items are selected and a IDataObject
    //          that contains the items is required.
    ATL::CComPtr<IDataObject> CreateDataObject(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST* ppidl)
    {
        return CShellFolderDataObject::CreateInstance(pidlFolder, cidl, ppidl, this);
    }

    // Purpose: called by MSF/shell when it want the current list of
    //          all items  The shell will walk all IDs and then release the enum.
    ATL::CComPtr<IEnumIDList> CreateEnumIDList(HWND /*hwnd*/, DWORD grfFlags) const
    {
        return EnumIDList::CreateInstance(GetPathFolderFile(), m_strSubFolder, grfFlags);
    }

    // Purpose: called by MSF when there is no global settings for all items.
    SFGAOF GetAttributeOf(unsigned int cidl, const VVVItem& item, SFGAOF /*sfgofMask*/) const
    {
        return item.GetAttributeOf(cidl == 1, IsReadOnly(GetPathFolderFile()));
    }

    // Purpose: called by MSF to tell the shell which panes to show.
    // It is essential to override this function to control which explorer panes are visible as by default no panes are shown.
    EXPLORERPANESTATE GetPaneState(_In_ REFEXPLORERPANE ep)
    {
        if (ep == __uuidof(MSF::EP_Ribbon))
            return EPS_DEFAULT_ON;

        return EPS_DONTCARE;
    }

    // Purpose: called by the default context menu. Gives an option to merge
    //          extra commands into the menu.
    HRESULT OnDfmMergeContextMenu(IDataObject* pdataobject, UINT /*uFlags*/, QCMINFO& qcminfo)
    {
        MSF::CCfShellIdList itemlist(pdataobject);

        if (itemlist.GetItemCount() == 1 && !VVVItem(itemlist.GetItem(0)).IsFolder())
        {
            // Add 'open' if only 1 item is selected.
            MSF::CMenu menu(true);
            menu.AddDefaultItem(ID_DFM_CMD_OPEN, L"&Open");
            MergeMenus(qcminfo, menu);

            // Note: XP will automatic make first menu item the default.
            //       Win98, ME and 2k don't do this, so must add as default item.
        }

        return S_OK;
    }

    // Purpose: Called to get the help string for added menu items.
    std::wstring OnDfmGetHelpText(unsigned short nCmdId)
    {
        return MSF::LoadResourceString(IDS_SHELLFOLDER_DFM_HELP_BASE + nCmdId);
    }

    HRESULT OnDfmInvokeAddedCommand(HWND hwnd, IDataObject* pdataobject, int nId)
    {
        switch (nId)
        {
            case ID_DFM_CMD_OPEN:
                OnOpen(hwnd, pdataobject);
                break;

            default:
                ATLASSERT(false); // unknown command id detected.
                break;
        }

        return S_OK;
    }

    // Purpose: handle 'open' by showing the name of the selected item.
    void OnOpen(HWND hwnd, IDataObject* pdataobject) const
    {
        MSF::CCfShellIdList cfshellidlist(pdataobject);
        ATLASSERT(cfshellidlist.GetItemCount() == 1);

        VVVItem item(cfshellidlist.GetItem(0));

        if (item.IsFolder())
        {
            GetShellBrowser().BrowseObject(item.GetItemIdList(),
                SBSP_DEFBROWSER | SBSP_RELATIVE);
        }
        else
        {
            auto strMessage = L"Open on: " + item.GetName();
            IsolationAwareMessageBox(hwnd, strMessage.c_str(), L"Open", MB_OK | MB_ICONQUESTION);
        }
    }

    // Purpose: Called by the shell/MSF when an item must be renamed.
    LPITEMIDLIST OnSetNameOf(HWND /*hwnd*/, const VVVItem& item, const wchar_t* szNewName, SHGDNF shgndf)
    {
        MSF::RaiseExceptionIf(shgndf != SHGDN_NORMAL && shgndf != SHGDN_INFOLDER); // not supported 'name'.

        MSF::CPidl pidl(VVVItem::CreateItemIdList(item.GetID(), item.GetSize(), item.IsFolder(), szNewName));

        VVVFile(GetPathFolderFile(), m_strSubFolder).SetItem(VVVItem(pidl));

        return pidl.Detach();
    }

    // Purpose: handles the 'properties request.
    //          The property sheet/page allows the user to change
    //          the name and size of an item.
    long OnProperties(HWND hwnd, CVVVItemList& items)
    {
        ATLASSERT(items.size() == 1);
        VVVItem& item = items[0];

        long wEventId;
        if (VVVPropertySheet(item, this).DoModal(hwnd, wEventId) > 0 && wEventId != 0)
        {
            VVVFile vvvfile(GetPathFolderFile(), m_strSubFolder);
            vvvfile.SetItem(item);
        }

        return wEventId;
    }

    // Purpose: Called by MSF/shell when items must be deleted.
    long OnDelete(HWND hwnd, CVVVItemList& items) const
    {
        if (!hwnd && !UserConfirmsFileDelete(hwnd, items))
            return 0; // user wants to abort the file deletion process.

        VVVFile(GetPathFolderFile(), m_strSubFolder).DeleteItems(items);

        return SHCNE_DELETE;
    }

    // Purpose: called by the standard MSF drag handler during drag operations.
    bool IsSupportedClipboardFormat(IDataObject* pdataobject)
    {
        return MSF::CfHDrop::IsFormat(pdataobject);
    }

    // Purpose: called when items are pasted or dropped on the shellfolder.
    DWORD AddItemsFromDataObject(DWORD dwEffect, IDataObject* pdataobject)
    {
        MSF::CfHDrop cfhdrop(pdataobject);

        unsigned int nFiles = cfhdrop.GetFileCount();
        for (unsigned int i = 0; i < nFiles; ++i)
        {
            AddItem(wstring(cfhdrop.GetFile(i))); // TOOD
        }

        // The VVV sample cannot use optimized move. Just return dwEffect as passed.
        return dwEffect;
    }

    void OnError(HRESULT hr, HWND hwnd, ErrorContext /*errorContext*/)
    {
        auto message = MSF::LoadResourceString(IDS_SHELLFOLDER_CANNOT_PERFORM) + MSF::FormatLastError(static_cast<DWORD>(hr));
        IsolationAwareMessageBox(hwnd, message.c_str(),
            MSF::LoadResourceString(IDS_SHELLEXT_ERROR_CAPTION).c_str(), MB_OK | MB_ICONERROR);
    }

protected:

    ShellFolder()
    {
        // Register the columns the folder supports in 'detailed' mode.
        RegisterColumn(IDS_SHELLEXT_NAME, LVCFMT_LEFT);
        RegisterColumn(IDS_SHELLEXT_SIZE, LVCFMT_RIGHT);
    }

private:

    // Purpose: Ask the user if he is really sure about the file delete action.
    //          Deleted files cannot be restored from the recycle bin.
    bool UserConfirmsFileDelete(HWND hwnd, const CVVVItemList& items) const
    {
        ATL::CString strMessage;
        UINT nCaptionResId;

        if (items.size() == 1)
        {
            strMessage.FormatMessage(IDS_SHELLFOLDER_DELETE, items[0].GetDisplayName().c_str());
            nCaptionResId = IDS_SHELLFOLDER_FILE_DELETE_CAPTION;
        }
        else
        {
            strMessage.FormatMessage(IDS_SHELLFOLDER_MULTIPLE_DELETE,
                MSF::ToString(static_cast<unsigned int>(items.size())).c_str());
            nCaptionResId = IDS_SHELLFOLDER_FILES_DELETE_CAPTION;
        }

        return IsolationAwareMessageBox(hwnd, strMessage,
            MSF::LoadString(nCaptionResId), MB_YESNO | MB_ICONQUESTION) == IDYES;
    }

    void AddItem(const wstring& strFile) const
    {
        VVVFile vvvfile(GetPathFolderFile(), m_strSubFolder);

        MSF::CPidl pidlItem(vvvfile.AddItem(strFile));

        ReportAddItem(pidlItem);
    }

    static bool IsReadOnly(const wstring& strFileName)
    {
        auto attributes = GetFileAttributes(strFileName.c_str());
        return (attributes & FILE_ATTRIBUTE_READONLY) != 0;
    }

    // Member variables
    wstring m_strSubFolder;
};


OBJECT_ENTRY_AUTO(__uuidof(ShellFolder), ShellFolder)
